<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Pixel Snowboard Sprint</title>
  <style>
    :root {
      --ink: #0e1f2f;
      --mint: #b0f5f0;
      --violet: #5b4b8a;
      --sun: #ffd466;
      --snow: #d9f3ff;
      --pine: #1c6038;
      --pine-dark: #0f3f25;
      --danger: #ff6b6b;
    }
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      background: radial-gradient(circle at 25% 15%, #c7f0ff 0, #c7f0ff 16%, #8dcff8 35%, #5e9cd9 70%, #3c6d9f 100%);
      color: var(--ink);
      font-family: "Courier New", monospace;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .frame {
      position: relative;
      width: min(1100px, 100%);
      aspect-ratio: 16 / 9;
      background: linear-gradient(#eff8ff 0%, #def3ff 40%, #d4f0ff 100%);
      border: 6px solid var(--ink);
      box-shadow: 0 18px 48px rgba(10, 24, 46, 0.35), inset 0 0 0 4px #fff;
      border-radius: 12px;
      overflow: hidden;
    }
    header {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 3;
      padding: 6px 10px;
      background: var(--ink);
      color: #e6f5ff;
      border: 3px solid #e6f5ff;
      box-shadow: 0 0 0 3px var(--ink), 0 8px 0 var(--ink);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: clamp(12px, 1.8vw, 16px);
    }
    #hud {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 3;
      background: rgba(14, 31, 47, 0.82);
      color: #e7f8ff;
      border: 3px solid #e7f8ff;
      padding: 8px 10px;
      font-size: clamp(12px, 1.6vw, 16px);
      box-shadow: 0 0 0 3px var(--ink);
      text-align: right;
      min-width: 160px;
      line-height: 1.5;
    }
    canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
      background: transparent;
    }
    #overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(14, 31, 47, 0.7), rgba(14, 31, 47, 0.85));
      color: #e6f5ff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
      text-align: center;
      padding: 18px;
      z-index: 4;
    }
    #overlay.hidden {
      display: none;
    }
    .panel {
      background: var(--ink);
      border: 4px solid #e6f5ff;
      box-shadow: 0 0 0 4px var(--ink), 0 10px 0 var(--ink);
      padding: 14px 16px;
      max-width: 560px;
      text-align: center;
    }
    .panel h1 {
      font-size: clamp(18px, 3vw, 28px);
      margin-bottom: 10px;
      letter-spacing: 2px;
      color: var(--sun);
    }
    .panel p {
      font-size: clamp(13px, 1.5vw, 16px);
      line-height: 1.6;
      margin-bottom: 8px;
      color: #dff4ff;
    }
    .panel strong {
      color: var(--mint);
    }
    .panel button {
      padding: 10px 22px;
      border: 4px solid #e6f5ff;
      background: var(--sun);
      color: var(--ink);
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 0 0 0 4px var(--ink), 0 8px 0 var(--ink);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .panel button:active {
      transform: translateY(4px);
      box-shadow: 0 0 0 4px var(--ink), 0 4px 0 var(--ink);
    }
    #touch-controls {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 3;
      pointer-events: none;
    }
    .touch-btn {
      pointer-events: auto;
      width: 70px;
      height: 70px;
      background: rgba(14, 31, 47, 0.7);
      border: 4px solid #e6f5ff;
      color: #e6f5ff;
      font-size: 30px;
      display: grid;
      place-items: center;
      box-shadow: 0 0 0 4px var(--ink);
      border-radius: 12px;
      touch-action: manipulation;
    }
    .touch-btn:active {
      background: rgba(14, 31, 47, 0.9);
    }
    @media (max-width: 820px) {
      body {
        padding: 10px;
      }
      .frame {
        aspect-ratio: 10 / 16;
      }
      header {
        font-size: 12px;
      }
      #hud {
        min-width: 0;
        font-size: 12px;
      }
      .touch-btn {
        width: 64px;
        height: 64px;
      }
    }
  </style>
</head>
<body>
  <div class="frame">
    <header>Pixel Snowboard Sprint</header>
    <div id="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Best: <span id="best">0</span></div>
      <div>Speed: <span id="speed">0</span> km/h</div>
    </div>
    <canvas id="game" aria-label="Retro snowboard run game"></canvas>
    <div id="overlay">
      <div class="panel">
        <h1>Ride the Retro Ridge</h1>
        <p>Be the pixelated rider, weave through trees, and chase a new best run.</p>
        <p><strong>Desktop:</strong> arrows or A / D to steer. <strong>Mobile:</strong> tap buttons or drag.</p>
        <p>Press <strong>space</strong> or hit start to drop in.</p>
        <button id="startBtn" type="button">Start Run</button>
      </div>
    </div>
    <div id="touch-controls">
      <button class="touch-btn" id="btn-left" aria-label="Move left">◄</button>
      <button class="touch-btn" id="btn-right" aria-label="Move right">►</button>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false;

      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const speedEl = document.getElementById("speed");
      const overlay = document.getElementById("overlay");
      const startBtn = document.getElementById("startBtn");
      const touchLeft = document.getElementById("btn-left");
      const touchRight = document.getElementById("btn-right");

      let width = 0;
      let height = 0;

      const player = {
        x: 0,
        y: 0,
        size: 20,
        speed: 240,
        tilt: 0,
        targetX: 0,
      };

      let snow = [];
      let trees = [];
      let particles = [];
      let running = false;
      let gameOver = false;
      let lastTime = 0;
      let score = 0;
      let best = Number(localStorage.getItem("pixel-snow-best") || 0);
      let spawnTimer = 0;
      let spawnDelay = 0.9;
      let difficultyTimer = 0;

      const input = { left: false, right: false, pointerActive: false };

      function resize() {
        const rect = canvas.parentElement.getBoundingClientRect();
        width = Math.floor(rect.width);
        height = Math.floor(rect.height);
        canvas.width = width;
        canvas.height = height;
        player.y = Math.floor(height * 0.8);
        player.x = player.targetX = width / 2;
        player.size = Math.max(18, Math.floor(width * 0.025));
        initSnow();
      }

      window.addEventListener("resize", resize);
      resize();
      bestEl.textContent = best.toFixed(0);

      function initSnow() {
        snow = Array.from({ length: 120 }, () => ({
          x: Math.random() * width,
          y: Math.random() * height,
          speed: 30 + Math.random() * 50,
          size: 1 + Math.random() * 2,
        }));
      }

      function startGame() {
        trees = [];
        particles = [];
        score = 0;
        spawnDelay = 0.9;
        spawnTimer = 0;
        difficultyTimer = 0;
        gameOver = false;
        running = true;
        overlay.classList.add("hidden");
        player.x = player.targetX = width / 2;
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function endGame() {
        running = false;
        gameOver = true;
        overlay.classList.remove("hidden");
        startBtn.textContent = "Retry Run";
        localStorage.setItem("pixel-snow-best", best.toFixed(0));
      }

      function spawnTree() {
        const size = Math.max(16, Math.random() * 18 + player.size * 0.6);
        const margin = size + 8;
        const x = margin + Math.random() * (width - margin * 2);
        trees.push({
          x,
          y: -size * 2,
          size,
          sway: Math.random() * Math.PI * 2,
        });
      }

      function updateSnow(dt, worldSpeed) {
        for (const flake of snow) {
          flake.y += (flake.speed + worldSpeed * 0.2) * dt;
          flake.x += Math.sin(flake.y * 0.02) * 5 * dt;
          if (flake.y > height) {
            flake.y = -4;
            flake.x = Math.random() * width;
          }
        }
      }

      function updateTrees(dt, worldSpeed) {
        spawnTimer -= dt;
        difficultyTimer += dt;
        if (spawnTimer <= 0) {
          spawnTree();
          spawnDelay = Math.max(0.35, spawnDelay - 0.01);
          spawnTimer = spawnDelay + Math.random() * 0.15;
        }

        const drift = Math.sin(performance.now() * 0.0013) * 18;
        for (const tree of trees) {
          tree.y += worldSpeed * dt;
          tree.x += Math.sin(tree.sway + performance.now() * 0.001) * 10 * dt;
          tree.x += drift * dt;
        }
        trees = trees.filter((t) => t.y < height + t.size * 2);
      }

      function updateParticles(dt, worldSpeed) {
        for (const p of particles) {
          p.y += worldSpeed * dt * 1.2 + p.vy * dt;
          p.x += p.vx * dt;
          p.life -= dt;
        }
        particles = particles.filter((p) => p.life > 0);
      }

      function addPowderBurst() {
        for (let i = 0; i < 12; i++) {
          particles.push({
            x: player.x,
            y: player.y + player.size * 0.5,
            vx: (Math.random() - 0.5) * 160,
            vy: Math.random() * 40,
            life: 0.35 + Math.random() * 0.35,
          });
        }
      }

      function handleInput(dt) {
        const steerSpeed = player.speed;
        let direction = 0;
        if (input.left) direction -= 1;
        if (input.right) direction += 1;

        if (input.pointerActive) {
          const dx = player.targetX - player.x;
          direction = Math.max(-1, Math.min(1, dx * 0.02));
        }

        player.x += direction * steerSpeed * dt;
        player.tilt += (direction * 12 - player.tilt) * 6 * dt;
        player.x = Math.max(player.size * 0.6, Math.min(width - player.size * 0.6, player.x));
      }

      function collide(a, b) {
        const halfA = a.size * 0.5;
        const halfB = b.size * 0.45;
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        return dx < halfA + halfB && dy < halfA + halfB;
      }

      function drawBackground(worldSpeed) {
        const bandHeight = 60;
        const stripes = Math.ceil(height / bandHeight);
        for (let i = 0; i < stripes; i++) {
          const y = i * bandHeight;
          ctx.fillStyle = i % 2 === 0 ? "#e5f5ff" : "#d6edff";
          ctx.fillRect(0, y, width, bandHeight + 1);
        }

        // lane stripes
        ctx.fillStyle = "rgba(14,31,47,0.08)";
        for (let x = 0; x < width; x += 80) {
          ctx.fillRect(x, 0, 8, height);
        }

        // rolling hills in the distance
        ctx.fillStyle = "rgba(91,75,138,0.35)";
        ctx.fillRect(0, height * 0.05, width, 6);
        ctx.fillStyle = "rgba(91,75,138,0.18)";
        ctx.fillRect(0, height * 0.1, width, 6);

        drawSnow();
        drawParticles();
      }

      function drawParticles() {
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        for (const p of particles) {
          ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 3, 3);
        }
      }

      function drawSnow() {
        ctx.fillStyle = "#ffffff";
        for (const flake of snow) {
          ctx.fillRect(Math.floor(flake.x), Math.floor(flake.y), flake.size, flake.size);
        }
      }

      function drawTree(tree) {
        const s = tree.size;
        const x = tree.x;
        const y = tree.y;
        ctx.fillStyle = varColorStep(s, 0);
        ctx.fillRect(x - s * 0.3, y + s * 0.5, s * 0.6, s * 0.5);

        const base = [
          { color: varColorStep(s, 1), w: 1.2 },
          { color: varColorStep(s, 2), w: 1.0 },
          { color: varColorStep(s, 3), w: 0.8 },
        ];
        base.forEach((b, i) => {
          ctx.fillStyle = b.color;
          const h = s * 0.38;
          const topY = y + (2 - i) * (s * 0.25);
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x - s * b.w * 0.5, topY + h);
          ctx.lineTo(x + s * b.w * 0.5, topY + h);
          ctx.closePath();
          ctx.fill();
        });
      }

      function varColorStep(size, idx) {
        const colors = [varColor("--pine-dark"), varColor("--pine"), "#2a8e55", "#38b26a"];
        return colors[idx] || colors[colors.length - 1];
      }

      function varColor(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      }

      function drawPlayer() {
        const scale = player.size / 12;
        const px = Math.floor(player.x);
        const py = Math.floor(player.y);
        ctx.save();
        ctx.translate(px, py);
        ctx.rotate((player.tilt * Math.PI) / 180);
        const sprite = [
          "....22.....",
          "...2222....",
          "..222222...",
          "..222222...",
          "..211112...",
          "..211112...",
          "..241142...",
          "..244442...",
          "..444442...",
          "..444442...",
          "..454542...",
          "..455542...",
          "..055550...",
        ];
        const palette = {
          "0": "#ff6b6b",
          "1": "#ffd466",
          "2": "#0e1f2f",
          "4": "#ffffff",
          "5": "#5b4b8a",
        };
        for (let row = 0; row < sprite.length; row++) {
          for (let col = 0; col < sprite[row].length; col++) {
            const key = sprite[row][col];
            if (key === ".") continue;
            ctx.fillStyle = palette[key] || "#ffffff";
            ctx.fillRect(
              Math.floor((col - sprite[row].length / 2) * scale),
              Math.floor((row - sprite.length / 2) * scale),
              Math.ceil(scale),
              Math.ceil(scale)
            );
          }
        }

        // board shadow
        ctx.fillStyle = "rgba(14,31,47,0.35)";
        ctx.fillRect(-scale * 6, scale * 5, scale * 12, scale * 1.2);
        ctx.restore();
      }

      function drawTrees() {
        for (const tree of trees) {
          drawTree(tree);
        }
      }

      function updateScore(worldSpeed, dt) {
        score += (worldSpeed * dt) / 4;
        if (score > best) {
          best = score;
          bestEl.textContent = best.toFixed(0);
        }
        scoreEl.textContent = score.toFixed(0);
        speedEl.textContent = Math.max(10, Math.floor(worldSpeed / 2)).toFixed(0);
      }

      function loop(timestamp) {
        if (!running) return;
        const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
        lastTime = timestamp;

        const worldSpeed = 160 + score * 0.4;
        updateSnow(dt, worldSpeed);
        updateTrees(dt, worldSpeed);
        updateParticles(dt, worldSpeed);
        handleInput(dt);
        updateScore(worldSpeed, dt);

        ctx.clearRect(0, 0, width, height);
        drawBackground(worldSpeed);
        drawTrees();
        drawPlayer();

        for (const tree of trees) {
          if (collide(player, tree)) {
            addPowderBurst();
            endGame();
            break;
          }
        }

        if (running) requestAnimationFrame(loop);
      }

      function setInput(side, state) {
        input[side] = state;
      }

      window.addEventListener("keydown", (e) => {
        if (["ArrowLeft", "a", "A"].includes(e.key)) setInput("left", true);
        if (["ArrowRight", "d", "D"].includes(e.key)) setInput("right", true);
        if (e.key === " " && !running) {
          startGame();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (["ArrowLeft", "a", "A"].includes(e.key)) setInput("left", false);
        if (["ArrowRight", "d", "D"].includes(e.key)) setInput("right", false);
      });

      const pointerArea = canvas.parentElement;
      pointerArea.addEventListener("pointerdown", (e) => {
        input.pointerActive = true;
        player.targetX = e.clientX - pointerArea.getBoundingClientRect().left;
      });
      pointerArea.addEventListener("pointermove", (e) => {
        if (!input.pointerActive) return;
        player.targetX = e.clientX - pointerArea.getBoundingClientRect().left;
      });
      window.addEventListener("pointerup", () => {
        input.pointerActive = false;
      });

      touchLeft.addEventListener("pointerdown", () => setInput("left", true));
      touchLeft.addEventListener("pointerup", () => setInput("left", false));
      touchLeft.addEventListener("pointerout", () => setInput("left", false));
      touchRight.addEventListener("pointerdown", () => setInput("right", true));
      touchRight.addEventListener("pointerup", () => setInput("right", false));
      touchRight.addEventListener("pointerout", () => setInput("right", false));

      startBtn.addEventListener("click", startGame);
    })();
  </script>
</body>
</html>
